CTRL+SHIFT+T=open type - поиск нужного класса, навести курсор на класс и нажать CTRL+T чтобы увидеть что использует класс
CTRL+O=open methods - нажать в классе, чтобы увидеть какие он имеет методы

Debug - жук
F6 - вперед на шаг
F8 - до следующего breakpoint 

CTRL+SHIFT+I - выделить метод и узнать результат его выполения, тоже самое и с условиями (пример (i<5))
CTRL - навести на класс или переменную и можно увидеть, где объявляется

ALT+SHIFT+R - Rename переменные, классы и тд
ALT+SHIFT+T - extract variable/method 
ALT+SHIFT+S - автоматический конструктор Геттеры / Сеттеры

heap-> include object
stack-> include methods+local variable, preference
metaspace-> include classes, static data

Инкапсуляция - возможность разделить код на модули (классы), и скрыть определенные свойства
Наследование
над любым самым высшим классом есть класс Object, от которого наследуются такие методы как ToString, equals и тд.
у каждого класса 1 наследник
Полиморфизм -


finalaize - метод, который мы не вызываем, но его вызывает гарбич коллектор, чтобы удалить мусор

this - указывает на переменную, если они одинаковые
super -  указатель на самый высший класс

В intarface могут быть только константы и абстрактные методы

ЧИТАТЬ ПРО АНОНИМНЫЕ КЛАССЫ

Аннотации и Generics
часто встречаемые 
@Deprecated
@Override
@SupressWarnings например не используемая переменная

аннотация 
@Retention
RetentionPilicy.SOURCE - аннотация которая используется на этапе компиляции, потом дел
RetentionPilicy.RUNTIME - доступна во время выполнения
RetentionPilicy.CLASS - записываются в класс, но потом не используются

Wildcards (?) - collection <?> - в коллекции можно пихать все что угодно благодаря знаку вопрос
Wildcards (bounded, extends)
List<? extends Shape> - принимает всех наследников и сам Shape

КОЛЛЕКЦИИ
List<E>
-индексы, как у массивов
-дубликаты могут быть

ArrayList<E>-тот же массив но без размера
Класс LinkedList<E> - двухсвязный список (быстрое добавление удаление, но медленно ищет по индексу)

Интерфес Map<K,V>

Интерфейс Set<E>
не имеет дубликатов и индексов

Интерфейс Iterator
Очередь интерфейс Queue - хранилище элементов для обработки
FIFO, FILO 


ИСКЛЮЧЕНИЯ - это объект
генерируются - исполнительной системой и вручную
иерархия исключений - object (во главе) -> throwable -> error
										  			 -> exception
Класс error - коитические ошибки, которые кидаются самой JVM
Unchecked exception - runtime exception, error
Checked - которые требуют обработки

Правила 
1) если можно загулушить - глушим ( при этом метод выполнит задачу), если нет пробрасываем дальше через throws


Ошибки обработки исклюяений:
1)кидаются конкретные исклюяения, не обобщенные (нельзя throws exception, runtimeexception, throwexception)
ловятся также только конкретные
2)перехват логированием 
3)нельзя логировать и кидать одновременно
4)программа это много потоков. если исключение долетает до верха, поток падает, но программа нет. нельзя исключением прерывать (управлять) поток
5)нельзя обработать само исключение и забыть про его причину
6)стараться не ходить к более обобщенному исключению от конкретного
7)не нужно делать лишних действий над исключениями


ПОТОКИ ввода-вывода
stream -поток для работы с байтами
-InputStrem (read, считывание)
--FileInputStream
--ByteArray..
--Filter...
---Buffered...
---Data...
--Object
-OutputStream

Reader\Wraiter - с символами (в них встроена операция конверсии (кодировка))

Потоки всегда нужно закрывать close();

BufferedReader br = new BufferedReader(reader) //паттерн-декоратор, который используется в java.io - обертка

Serializable
Сериализация - сохранение состояния объекта в последовательность байт
Десериализация - восстановление объекта из этих байт

если нужно сериализировать объект, нужно прописать implements Serializable


на слова
бежим по словам
if(f.exists){}


2. берем любой диск, распечатываем деревом папки
проверяем папка,либо файл, если файл,дальше не лезем, если папка идем дальше	


Потоки
у каждого потока свой стек
 Thread currentThread = Thread.currentThread(); //получение текущего потока
 главный поток
 при старте
 порождает дочерние
 порождается через thread
 
СВОЙСТВА потока - нельзя менять
id
name
daemon - поток, кторый автоматич завершает работу когда не остается ни одного потока не демона (обычного потока)
priority
  
volatile - свойство отключило локальный кеш, то есть поток работает с памятью напрямую
synchronized - синхронизированный блок кода выполняется только одним потоком

если метод static synchronized, монитор сам класс, если synchronized, но не static- this
разобраться с synchronized, будет в тесте

DEADLOCK - взаимная блокировка
	
ОТРАБОТАТЬ ПРИМЕР RunThread3

Приостановка потока - через метод sleep класса Thread
					- через метод join - ждет пока выполнится другой поток, потом запускает старый
					
Метод Yield  - передает упраление другим потокам

Thread interruption (program+incremenator

Thread.interrupt() - метод, по умолчанию false, после вызова становится true.... Читается методом interrupted() - плюс в том, что не нужно создавать флажок и позволяет разбудить поток

Wait/notify/notifyAll - методы класса Object для управления потоками
notify будит спящий поток в программе
wait останавливает поток 
notifyAll будит все потоки в программе

Executor service:stop thread management pain






