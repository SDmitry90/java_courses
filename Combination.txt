CTRL+SHIFT+T=open type - поиск нужного класса, навести курсор на класс и нажать CTRL+T чтобы увидеть что использует класс
CTRL+O=open methods - нажать в классе, чтобы увидеть какие он имеет методы

Debug - жук
F6 - вперед на шаг
F8 - до следующего breakpoint 

CTRL+SHIFT+I - выделить метод и узнать результат его выполения, тоже самое и с условиями (пример (i<5))
CTRL - навести на класс или переменную и можно увидеть, где объявляется

ALT+SHIFT+R - Rename переменные, классы и тд
ALT+SHIFT+T - extract variable/method 
ALT+SHIFT+S - автоматический конструктор Геттеры / Сеттеры

heap-> include object
stack-> include methods+local variable, preference
metaspace-> include classes, static data

Инкапсуляция - возможность разделить код на модули (классы), и скрыть определенные свойства
Наследование
над любым самым высшим классом есть класс Object, от которого наследуются такие методы как ToString, equals и тд.
у каждого класса 1 наследник
Полиморфизм -


finalaize - метод, который мы не вызываем, но его вызывает гарбич коллектор, чтобы удалить мусор

this - указывает на переменную, если они одинаковые
super -  указатель на самый высший класс

В intarface могут быть только константы и абстрактные методы

ЧИТАТЬ ПРО АНОНИМНЫЕ КЛАССЫ

Аннотации и Generics
часто встречаемые 
@Deprecated
@Override
@SupressWarnings например не используемая переменная

аннотация 
@Retention
RetentionPilicy.SOURCE - аннотация которая используется на этапе компиляции, потом дел
RetentionPilicy.RUNTIME - доступна во время выполнения
RetentionPilicy.CLASS - записываются в класс, но потом не используются

Wildcards (?) - collection <?> - в коллекции можно пихать все что угодно благодаря знаку вопрос
Wildcards (bounded, extends)
List<? extends Shape> - принимает всех наследников и сам Shape

КОЛЛЕКЦИИ
_____________________________
List<E>
-индексы, как у массивов
-дубликаты могут быть

ArrayList<E>-тот же массив но без размера
Класс LinkedList<E> - двухсвязный список (быстрое добавление удаление, но медленно ищет по индексу)

Интерфес Map<K,V>

Интерфейс Set<E>
не имеет дубликатов и индексов

Интерфейс Iterator
Очередь интерфейс Queue - хранилище элементов для обработки
FIFO, FILO 


ИСКЛЮЧЕНИЯ - это объект
____________________________
генерируются - исполнительной системой и вручную
иерархия исключений - object (во главе) -> throwable -> error
										  			 -> exception
Класс error - коитические ошибки, которые кидаются самой JVM
Unchecked exception - runtime exception, error
Checked - которые требуют обработки

Правила 
1) если можно загулушить - глушим ( при этом метод выполнит задачу), если нет пробрасываем дальше через throws

Ошибки обработки исклюяений:
1)кидаются конкретные исклюяения, не обобщенные (нельзя throws exception, runtimeexception, throwexception)
ловятся также только конкретные
2)перехват логированием 
3)нельзя логировать и кидать одновременно
4)программа это много потоков. если исключение долетает до верха, поток падает, но программа нет. нельзя исключением прерывать (управлять) поток
5)нельзя обработать само исключение и забыть про его причину
6)стараться не ходить к более обобщенному исключению от конкретного
7)не нужно делать лишних действий над исключениями

ПОТОКИ ввода-вывода
___________________________________
stream -поток для работы с байтами
-InputStrem (read, считывание)
--FileInputStream
--ByteArray..
--Filter...
---Buffered...
---Data...
--Object
-OutputStream

Reader\Wraiter - с символами (в них встроена операция конверсии (кодировка))

Потоки всегда нужно закрывать close();

BufferedReader br = new BufferedReader(reader) //паттерн-декоратор, который используется в java.io - обертка

Serializable
Сериализация - сохранение состояния объекта в последовательность байт
Десериализация - восстановление объекта из этих байт

если нужно сериализировать объект, нужно прописать implements Serializable

ПОТОКИ
____________________________
у каждого потока свой стек
 Thread currentThread = Thread.currentThread(); //получение текущего потока
 главный поток
 при старте
 порождает дочерние
 порождается через thread
 
СВОЙСТВА потока - нельзя менять
id
name
daemon - поток, кторый автоматич завершает работу когда не остается ни одного потока не демона (обычного потока)
priority
  
volatile - свойство отключило локальный кеш, то есть поток работает с памятью напрямую
synchronized - синхронизированный блок кода выполняется только одним потоком

если метод static synchronized, монитор сам класс, если synchronized, но не static- this
разобраться с synchronized, будет в тесте

DEADLOCK - взаимная блокировка
	
ОТРАБОТАТЬ ПРИМЕР RunThread3

Приостановка потока - через метод sleep класса Thread
					- через метод join - ждет пока выполнится другой поток, потом запускает старый
					
Метод Yield  - передает упраление другим потокам

Thread interruption (program+incremenator

Thread.interrupt() - метод, по умолчанию false, после вызова становится true.... Читается методом interrupted() - плюс в том, что не нужно создавать флажок и позволяет разбудить поток

Wait/notify/notifyAll - методы класса Object для управления потоками
notify будит спящий поток в программе
wait останавливает поток 
notifyAll будит все потоки в программе

Executor service:stop thread management pain



Принципы и шаблоны проектирования
_________________________________
UML-язык графического моделирования, состоит из диаграмм case и class

Solid principles - обязательно спрашивают на собесах и их нужно знать...
1-принцип единой отвественности (конкретный класс должен решать конкретную задачу - много методов разбиваются на модули, отдельные классы)
2-принцип открытости/закрытости (программные сущности должны быть открыты для расширения, закрыты для модификации)
выход
пишем интерфейс
имплементимся от него
в основной класс передаем какое-то общее совйство и через него работаем. Получается основной не трогаем,меняем дополнительные
3-результат выполнения кода должен быть предсказуемый
4-принцип разделения интерфейсов (лучше много маленьких, чем один толстый интерфейс и использовать по несколько необходимых маленьких)
5-принцип инверсии зависимостей (модули верхних уровней не должны зависеть от модулей нижних уровней, абстракции не должны зависеть от деталей, детали должны зависеть от абстракций, верхние и нижние модули должны зависеть от абстракций)
базы данных(lv3)-логика(lv2)-интерфес пользователя(lv1) - бд - это верхний уровень

Паттерны проектирования
-шаблоны решения типичных задач
Категории:
-порождающие
-структурные
-поведенческие

JDK8
_______________________________
soft version
v.1.0.6
1- major version
2- minor 
3- patch

Метод foreach переписали, закинули в интерфес Итератор и все интерфесы коллекций имплементили от Итератора

Разница между статик и дефолт методами:
1. Дефолты можно переопределять, статики - нет
2. Статик доступны по имени интерфейса

Лямбда выражение - основная фича 
- специальный синтаксис для определения функциональных объектов, заимствованный из лямбда исчисления. Применяется как правило при объявлении анонимных функций по месту их использования, и обычно допускает ЗАМЫКАНИЕ на лексический контекст, в котором это использовано.
- особый синтаксис, замена анонимным классам, замыканием становится когда ссылается на внешнее лексическое значение

Ссылаться можно только на не final значение

Лямбда выражение
Arrays.asList("a", "b", "d").forEach(e -> System.out.println(e));

Функциональный интерфейс - только с одним методом

Ссылочные методы:оператор
:: - ссылка на метод
Ссылочные методы:
конструктор
static method
method of object
non static method of class ()

Класс Optional
сокращение вложенностей

Stream
parallel stream - работает быстрее, но использовать постоянно нельзя
Нужно использовать если:
-большая коллекция и обработка занимает большое время
-есть проблема производительности и необходимо ее улучшить
-не используются потоки в других местах

parallel stream не решает вопросы синхронизации.






